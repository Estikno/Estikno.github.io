<!DOCTYPE html><html lang="en" data-theme="dark" class="dark" data-astro-cid-bvzihdzo> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=1"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=1"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=1"><link rel="icon" type="image/png" href="/favicon.png?v=1"><link rel="shortcut icon" href="/favicon.ico?v=1"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="David – Personal Blog &#38; Portfolio" href="https://example.com/rss.xml"><meta name="generator" content="Astro v5.12.9"><!-- Font preloads --><link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin><link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://example.com/blog/building-a-unixshell-in-rust-part-2/"><!-- Robots --><meta name="robots" content="index,follow,max-image-preview:large"><!-- Theme color (supports dark/light) --><meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#0b0b0b"><!-- Primary Meta Tags --><title>Building a Unix-shell in Rust - Part 2</title><meta name="title" content="Building a Unix-shell in Rust - Part 2"><meta name="description" content="In this second part of the series on building a Unix shell in Rust, we dive into the essential steps of reading user input, parsing it into commands, and classifying those commands for execution."><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:site_name" content="David – Personal Blog &#38; Portfolio"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://example.com/blog/building-a-unixshell-in-rust-part-2/"><meta property="og:title" content="Building a Unix-shell in Rust - Part 2"><meta property="og:description" content="In this second part of the series on building a Unix shell in Rust, we dive into the essential steps of reading user input, parsing it into commands, and classifying those commands for execution."><meta property="og:image" content="https://example.com/_astro/ShellPhoto.gsyqkmHT.png"><meta property="og:image:alt" content="Building a Unix-shell in Rust - Part 2"><!-- Twitter --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@guihubie"><meta property="twitter:url" content="https://example.com/blog/building-a-unixshell-in-rust-part-2/"><meta property="twitter:title" content="Building a Unix-shell in Rust - Part 2"><meta property="twitter:description" content="In this second part of the series on building a Unix shell in Rust, we dive into the essential steps of reading user input, parsing it into commands, and classifying those commands for execution."><meta property="twitter:image" content="https://example.com/_astro/ShellPhoto.gsyqkmHT.png"><meta property="og:type" content="article"><!-- Article specific OG meta --><meta property="article:published_time" content="2024-07-27T00:00:00.000Z"><meta property="article:author" content="Site Author"><meta property="article:tag" content="rust"><meta property="article:tag" content="shell"><!-- JSON-LD: Article --><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Building a Unix-shell in Rust - Part 2","description":"In this second part of the series on building a Unix shell in Rust, we dive into the essential steps of reading user input, parsing it into commands, and classifying those commands for execution.","image":"https://example.com/_astro/ShellPhoto.gsyqkmHT.png","datePublished":"2024-07-27T00:00:00.000Z","author":[{"@type":"Person","name":"Site Author"}],"publisher":{"@type":"Organization","name":"guihubie.com"},"mainEntityOfPage":"https://example.com/blog/building-a-unixshell-in-rust-part-2/","url":"https://example.com/blog/building-a-unixshell-in-rust-part-2/"}</script><!-- JSON-LD: Breadcrumbs --><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https://example.com/"},{"@type":"ListItem","position":2,"name":"Blog","item":"https://example.com/blog/"},{"@type":"ListItem","position":3,"name":"Building a Unix-shell in Rust - Part 2","item":"https://example.com/blog/building-a-unixshell-in-rust-part-2/"}]}</script><link rel="stylesheet" href="/_astro/about.DsQLGK1y.css">
<style>main[data-astro-cid-bvzihdzo]{width:1280px;max-width:calc(100% - 2em);margin:auto;background:var(--color-bg-primary)}.hero-image[data-astro-cid-bvzihdzo]{width:100%}.hero-image[data-astro-cid-bvzihdzo] img[data-astro-cid-bvzihdzo]{display:block;margin:0 auto;border-radius:12px;box-shadow:var(--box-shadow)}.prose[data-astro-cid-bvzihdzo]{width:100%;max-width:870px;margin:auto;padding:.05em;color:var(--color-text-secondary)}.title[data-astro-cid-bvzihdzo]{margin-bottom:1em;padding:1em 0;text-align:center;line-height:1}.title[data-astro-cid-bvzihdzo] h1[data-astro-cid-bvzihdzo]{margin:0 0 .5em;color:var(--color-text-primary)}.date[data-astro-cid-bvzihdzo]{margin-bottom:.5em;color:var(--color-text-muted)}.last-updated-on[data-astro-cid-bvzihdzo]{font-style:italic}
</style></head> <body data-astro-cid-bvzihdzo> <header class="bg-background text-foreground border-b sw-header"> <nav class="mx-auto max-w-6xl px-4 py-2 flex items-center justify-between"> <div class="flex items-center gap-3"> <a class="no-underline hover:opacity-90 flex items-center gap-2" href="/" aria-label="Home"> <img src="/favicon.png?v=1" alt="" aria-hidden="true" width="45" height="45"> </a> <div class="internal-links hidden md:flex items-center gap-2 ml-1"> <a href="/" class="px-2 py-3 text-[color:var(--color-text-secondary)] no-underline" data-astro-cid-2dpnh6aj> Home </a>  <a href="/portfolio" class="px-2 py-3 text-[color:var(--color-text-secondary)] no-underline" data-astro-cid-2dpnh6aj> Portfolio </a>  <a href="/about" class="px-2 py-3 text-[color:var(--color-text-secondary)] no-underline" data-astro-cid-2dpnh6aj> About </a>  <a href="/blog" class="px-2 py-3 text-[color:var(--color-text-secondary)] no-underline active" data-astro-cid-2dpnh6aj> Blog </a>  <!-- <a href="#contact" class="px-2 py-3 text-[color:var(--color-text-secondary)] no-underline">Contact</a> --> </div> </div> <div class="flex items-center gap-3"> <div class="social-links hidden md:flex items-center gap-3"> <!-- <a href="https://x.com/guihubie" target="_blank" class="group text-[color:var(--color-text-secondary)]"> --> <!-- <span class="sr-only">Follow on Twitter</span> --> <!-- X icon --> <!-- <svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="transition-colors group-hover:text-[color:var(--accent)]"><path fill="currentColor" d="M18.146 3H21l-7.5 8.574L22.5 21h-6.297l-4.93-5.597L5.5 21H3l8.106-9.266L3 3h6.453l4.466 5.07L18.146 3Zm-1.103 16.2h1.705L7.05 4.64H5.272l11.771 14.56Z"/></svg> --> <!-- </a> --> <a href="https://github.com/Estikno" target="_blank" class="group text-[color:var(--color-text-secondary)]"> <span class="sr-only">Go to GitHub</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="24" height="24" class="transition-colors group-hover:text-[color:var(--accent)]"><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg> </a> </div> <button type="button" class="sw-btn-sm no-underline flex items-center gap-1" aria-label="Toggle theme" aria-pressed="false" data-theme-toggle> <span class="sr-only">Toggle theme</span> <span class="theme-icon" aria-hidden="true"> <svg class="icon-sun" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"></path></svg> <svg class="icon-moon" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg> </span> <span class="label">Theme</span> </button> <script>
  (function () {
    const storageKey = 'theme';
    const root = document.documentElement;
    const btn = document.querySelector('[data-theme-toggle]');

    function applyTheme(theme) {
      const isDark = theme === 'dark';
      root.dataset.theme = isDark ? 'dark' : 'light';
      root.classList.toggle('dark', isDark);
      if (btn) btn.setAttribute('aria-pressed', String(isDark));
    }

    function getInitialTheme() {
      const saved = localStorage.getItem(storageKey);
      if (saved === 'dark' || saved === 'light') return saved;
      // Infer from current DOM as fallback
      return root.classList.contains('dark') || root.dataset.theme === 'dark' ? 'dark' : 'light';
    }

    let current = getInitialTheme();
    applyTheme(current);

    btn?.addEventListener('click', () => {
      current = current === 'dark' ? 'light' : 'dark';
      localStorage.setItem(storageKey, current);
      applyTheme(current);
    });
  })();
</script> <style>
  [data-theme-toggle] .icon-moon { display: none; }
  html[data-theme="dark"] [data-theme-toggle] .icon-sun { display: none; }
  html[data-theme="dark"] [data-theme-toggle] .icon-moon { display: inline; }
</style> <button type="button" aria-label="Open menu" aria-controls="mobile-menu" aria-expanded="false" data-menu-btn class="md:hidden inline-flex items-center justify-center w-10 h-10 rounded-lg text-[color:var(--color-text-secondary)] hover:text-white"> <svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true"><path fill="currentColor" d="M3 6h18v2H3V6Zm0 5h18v2H3v-2Zm0 5h18v2H3v-2Z"></path></svg> </button> </div> </nav> <div id="mobile-menu" class="md:hidden hidden border-t"> <div class="mx-auto max-w-6xl px-4 py-3 flex flex-col gap-2"> <div class="flex flex-col"> <a href="/" class="px-2 py-3" data-astro-cid-2dpnh6aj> Resume </a>  <a href="/portfolio" class="px-2 py-3" data-astro-cid-2dpnh6aj> Portfolio </a>  <a href="/about" class="px-2 py-3" data-astro-cid-2dpnh6aj> About </a>  <a href="/blog" class="px-2 py-3 active" data-astro-cid-2dpnh6aj> Blog </a>  <a href="#contact" class="px-2 py-3">Contact</a> </div> <div class="flex items-center gap-4 pt-2"> <a href="https://x.com/guihubie" target="_blank" class="group inline-flex items-center text-[color:var(--color-text-secondary)]"> <svg viewBox="0 0 24 24" width="22" height="22" aria-hidden="true" class="transition-colors group-hover:text-white"><path fill="currentColor" d="M18.146 3H21l-7.5 8.574L22.5 21h-6.297l-4.93-5.597L5.5 21H3l8.106-9.266L3 3h6.453l4.466 5.07L18.146 3Zm-1.103 16.2h1.705L7.05 4.64H5.272l11.771 14.56Z"></path></svg> </a> <a href="https://github.com/guihubie/free-astro-template" target="_blank" class="group inline-flex items-center text-[color:var(--color-text-secondary)]"> <svg viewBox="0 0 16 16" aria-hidden="true" width="22" height="22" class="transition-colors group-hover:text-white"><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg> </a> </div> </div> </div> </header> <script>
  const btn = document.querySelector('[data-menu-btn]');
  const panel = document.getElementById('mobile-menu');
  function toggleMenu() {
    if (!panel || !btn) return;
    const isOpen = !panel.classList.contains('hidden');
    if (isOpen) {
      panel.classList.add('hidden');
      btn.setAttribute('aria-expanded', 'false');
    } else {
      panel.classList.remove('hidden');
      btn.setAttribute('aria-expanded', 'true');
    }
  }
  btn?.addEventListener('click', toggleMenu);
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape') {
    if (!panel?.classList.contains('hidden')) toggleMenu();
  }});
  document.addEventListener('click', (e) => {
    if (!panel || !btn) return;
    const target = e.target;
    const clickedInside = panel.contains(target) || btn.contains(target);
    if (!clickedInside && !panel.classList.contains('hidden')) toggleMenu();
  });
</script> <main data-astro-cid-bvzihdzo> <article data-astro-cid-bvzihdzo> <div class="hero-image" data-astro-cid-bvzihdzo> <img src="/_astro/ShellPhoto.gsyqkmHT_ZN9npv.webp" alt data-astro-cid-bvzihdzo="true" loading="lazy" decoding="async" fetchpriority="auto" width="1020" height="510"> </div> <div class="prose" data-astro-cid-bvzihdzo> <div class="title" data-astro-cid-bvzihdzo> <div class="date" data-astro-cid-bvzihdzo> <time datetime="2024-07-27T00:00:00.000Z"> Jul 27, 2024 </time>  </div> <h1 data-astro-cid-bvzihdzo>Building a Unix-shell in Rust - Part 2</h1> <hr data-astro-cid-bvzihdzo> </div> <div class="sw-share group flex items-center gap-2"> <!-- <a href={xUrl} target="_blank" rel="noopener noreferrer" class="sw-share-btn" aria-label="Share on X" set:html={xIcon} /> --> <!-- <a href={hnUrl} target="_blank" rel="noopener noreferrer" class="sw-share-btn" aria-label="Share on Hacker News" set:html={hnIcon} /> --> <!-- <a href={liUrl} target="_blank" rel="noopener noreferrer" class="sw-share-btn" aria-label="Share on LinkedIn" set:html={liIcon} /> --> <!-- <a href={rdUrl} target="_blank" rel="noopener noreferrer" class="sw-share-btn" aria-label="Share on Reddit" set:html={rdIcon} /> --> </div> <div class="sw-post-meta flex items-start justify-between gap-4 py-2"> <div class="flex items-start gap-3"> <div class="w-12 h-12 rounded-full overflow-hidden border border-[color:var(--color-border-light)]"> <img src="/_astro/avatar.BQrnOBxq.png" alt="David" width="48" height="48" class="w-full h-full object-cover"> </div> <div class="flex flex-col"> <a href="/blog/author/site-author/" class="text-sm font-semibold text-[color:var(--color-text-primary)] hover:text-[color:var(--accent)]">Site Author</a> <div class="flex items-center gap-3 text-xs text-[color:var(--color-text-muted)]"> <div class="flex items-center gap-1"> <svg viewBox="0 0 24 24" width="14" height="14" aria-hidden="true"><path fill="currentColor" d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"></path></svg> <time datetime="2024-07-27T00:00:00.000Z"> Jul 27, 2024 </time> </div> <div class="flex items-center gap-1"> <svg viewBox="0 0 24 24" width="14" height="14" aria-hidden="true"> <path fill="currentColor" d="M12 22a10 10 0 1 1 0-20 10 10 0 0 1 0 20Zm0-18a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm1 9h3v-2h-2V7h-2v6Z"></path> </svg> <span>1 min read</span> </div> </div> </div> </div> </div>  <p>In the first post of this series, we laid the groundwork by discussing what a shell is and how it works. If you missed it, I suggest starting from there to get the full picture. Now, let’s dive into the next steps: reading user input, parsing that input into commands, and classifying those commands to execute the appropriate actions.</p>
<h2 id="reading-user-input">Reading User Input</h2>
<p>To start, we need our shell to read user input. This is the first step in our REPL (Read-Eval-Print-Loop) process. Here’s how we can achieve this in Rust:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">io</span><span style="color:#F97583">::</span><span style="color:#E1E4E8">{stdin, stdout, </span><span style="color:#B392F0">Write</span><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> anyhow</span><span style="color:#F97583">::</span><span style="color:#B392F0">Result</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">-></span><span style="color:#B392F0"> Result</span><span style="color:#E1E4E8">&#x3C;()> {</span></span>
<span class="line"><span style="color:#F97583">    loop</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">        // use the `>` character as the prompt</span></span>
<span class="line"><span style="color:#6A737D">        // need to explicitly flush this to ensure it prints before read_line</span></span>
<span class="line"><span style="color:#B392F0">        print!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"> "</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">        stdout</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">flush</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">?</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> input </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">        stdin</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">read_line</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&#x26;mut</span><span style="color:#E1E4E8"> input)</span><span style="color:#F97583">.</span><span style="color:#B392F0">unwrap</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    Ok</span><span style="color:#E1E4E8">(())</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="breaking-it-down">Breaking It Down</h3>
<ol>
<li>
<p><strong>Prompting the User:</strong> We use the <code>></code> character as the prompt. This signals to the user that the shell is ready for input.</p>
</li>
<li>
<p><strong>Flushing stdout:</strong> <code>stdout().flush()?;</code> ensures that the prompt is printed immediately, not buffered. This is crucial for a good user experience.</p>
</li>
<li>
<p><strong>Reading Input:</strong> We read the user input into a mutable <code>String</code> variable called <code>input</code> using <code>stdin().read_line(&#x26;mut input).unwrap();</code>. Even though this aproach of reading the user input is very bare bones, as the user cannot edit it while typing, not having the command history, etc. It is sufficient for now and it will be expanded in the future.</p>
</li>
</ol>
<p>By this point, we can display a prompt and capture user input. Let’s move on to parsing this input.</p>
<h2 id="parsing-the-input-into-commands">Parsing the Input into Commands</h2>
<p>Once we have the user input, we need to parse it into a command and its arguments. This helps us determine what action to take.</p>
<p>First, we trim the input using <code>input.trim()</code>, which removes any leading or trailing whitespace from the input string. Next, we split the input using <code>split_ascii_whitespace()</code>, which splits the input into an iterator of substrings separated by ASCII whitespace. To extract the command, we use <code>parts.next()</code>, which retrieves the first substring. If there’s no command (empty input), the loop continues. Finally, we extract the arguments by capturing the remaining substrings as the command’s arguments with <code>let args = parts;</code>.</p>
<p>Here is the code that does this process:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> parts </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> input</span><span style="color:#F97583">.</span><span style="color:#B392F0">trim</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">split_ascii_whitespace</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> command;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">match</span><span style="color:#E1E4E8"> parts</span><span style="color:#F97583">.</span><span style="color:#B392F0">next</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">    Some</span><span style="color:#E1E4E8">(com) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> command </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> com,</span></span>
<span class="line"><span style="color:#B392F0">    None</span><span style="color:#F97583"> =></span><span style="color:#F97583"> continue</span><span style="color:#E1E4E8">,  </span><span style="color:#6A737D">// continue if no command provided</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> args </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> parts;</span></span></code></pre>
<h2 id="classifying-commands">Classifying Commands</h2>
<p>With the command and arguments parsed, we need to classify and handle them appropriately.</p>
<p>To do this, we pass the command into a match block and check if it matches a built-in command. If it doesn’t, we assume the command is external and execute it. If it turns out not to be a correct command, we display an error message and restart the loop.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">match</span><span style="color:#E1E4E8"> command {</span></span>
<span class="line"><span style="color:#9ECBFF">    "cd"</span><span style="color:#F97583"> =></span><span style="color:#B392F0"> cd</span><span style="color:#E1E4E8">(args),</span></span>
<span class="line"><span style="color:#9ECBFF">    "exit"</span><span style="color:#F97583"> =></span><span style="color:#F97583"> break</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    command </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        let</span><span style="color:#E1E4E8"> child </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Command</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">(command)</span></span>
<span class="line"><span style="color:#F97583">            .</span><span style="color:#B392F0">args</span><span style="color:#E1E4E8">(args)</span></span>
<span class="line"><span style="color:#F97583">            .</span><span style="color:#B392F0">spawn</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        match</span><span style="color:#E1E4E8"> child {</span></span>
<span class="line"><span style="color:#B392F0">            Ok</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">mut</span><span style="color:#E1E4E8"> child) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> { child</span><span style="color:#F97583">.</span><span style="color:#B392F0">wait</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">?</span><span style="color:#E1E4E8">; },</span></span>
<span class="line"><span style="color:#B392F0">            Err</span><span style="color:#E1E4E8">(e) </span><span style="color:#F97583">=></span><span style="color:#B392F0"> eprintln!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"{}"</span><span style="color:#E1E4E8">, e)</span></span>
<span class="line"><span style="color:#E1E4E8">        };</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>For external commands, <code>Command::new(command).args(args).spawn()</code> tries to execute them. If the command executes successfully, <code>child.wait()?</code> waits for it to finish.</p>
<p>If the command is a built-in one, it is necessary to create a function that implements its functionality and call it with the arguments as parameters, like the <code>cd</code> function in the code above.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We’ve covered a lot in this post, from reading user input to parsing it into commands and arguments, and finally classifying and executing those commands. Our shell is taking shape, and we now have a basic REPL loop that can handle both built-in and external commands.</p>
<p>In the next post, we’ll dive deeper into implementing more built-in commands and improving the user experience. Stay tuned, and happy coding!</p>
<h2 id="next-steps">Next Steps</h2>
<p>In the next post, we’ll focus on refactoring the code to improve readability, maintainability, and extend functionality. Stay tuned!</p>  <nav class="sw-post-nav mt-8 pt-4 border-t border-[color:var(--color-border-light)]"><div class="flex flex-col md:flex-row md:justify-between gap-3 md:gap-4"><a href="/blog/building-a-unixshell-in-rust-part-1/" class="sw-nav-btn no-underline flex-1"><svg viewBox="0 0 24 24" width="16" height="16" aria-hidden="true"><path fill="currentColor" d="M15.41 7.41 14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg><div class="sw-nav-text"><span class="sw-nav-label">Previous</span><span class="truncate">Building a Unix-shell in Rust - Part 1</span></div></a><a href="/blog/building-a-unixshell-in-rust-part-3/" class="sw-nav-btn no-underline justify-end flex-1"><div class="sw-nav-text text-right"><span class="sw-nav-label">Next</span><span class="truncate">Building a Unix-shell in Rust - Part 3</span></div><svg viewBox="0 0 24 24" width="16" height="16" aria-hidden="true"><path fill="currentColor" d="m8.59 16.59 1.41 1.41 6-6-6-6-1.41 1.41L13.17 12z"></path></svg></a></div></nav> </div> </article> </main> <!-- <Footer /> --> </body></html>