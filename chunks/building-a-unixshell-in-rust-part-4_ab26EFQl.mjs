const id = "building-a-unixshell-in-rust-part-4.md";
						const collection = "blog";
						const slug = "building-a-unixshell-in-rust-part-4";
						const body = "\n![banner](../../assets/blog/Shell/4/banner_4.jpg)\n\nIn the last post, we tackled formatting code, organizing files, handling errors, adding pipes, and using Termion for input. This time, we'll be discussing the switch from Termion to Rustyline, adding a command history feature, implementing an init script, and creating an installation script. Let's dive in!\n\n## Changed from Termion to Rustyline\n\nGiven the difficulties with **Termion** and since I don't need to create a complex terminal layout, I decided to switch to **Rustyline**. This crate allows you to do simple things like letting the user edit the input, having a customizable prompt, command history, and other technical features.\n\nThis change was not only beneficial in terms of UI and features but also in performance and code readability. Instead of configuring the terminal layout from scratch, which is great for complex layouts, Rustyline provides a basic layout and events you can listen to before receiving the input, something the standard library lacks.\n\nHere is the `read_input` function implemented with Rustyline. It's much simpler and more readable than with Termion:\n\n```rust:prompt.rs\npub fn read_input(rl: &mut Editor<(), rustyline::history::FileHistory>) -> Option<String> {\n    // Read user input from the console using the rustyline library\n    match rl.readline(get_prompt().as_str()) {\n        // If the input was successfully read, add it to the history and return it\n        Ok(input) => {\n            if rl.add_history_entry(input.as_str()).is_err() {\n                println!(\"Failed to add input to history\");\n            }\n\n            Some(input)\n        }\n        Err(rustyline::error::ReadlineError::Interrupted) => {\n            println!(\"Interrupted process: {:?}\", rustyline::error::ReadlineError::Interrupted);\n            None\n        }\n        // If there was an error reading the input, print the error and return an empty String\n        Err(err) => {\n            println!(\"Error: {:?}\", err);\n            None\n        }\n    }\n}\n```\n\n## History Command\n\nJust like Bash has the `history` command, which allows you to view and manipulate the command history, I wanted to implement a similar feature in our shell. This enables users to customize their command history.\n\nAdding this feature was straightforward since Rustyline already has built-in support for command history. The implementation of the history command was also surprisingly simple. It doesn't do as much as the Bash version, but it is sufficient. The history file is stored in the home directory with the name `.oxsh_history`,\" similar to Bash.\n\n## Init Script\n\nI also added the possibility to read an initial script when starting the shell. This script has to be situated in the home directory of the user using the shell, but in the future, I might implement global init scripts.\n\nThese scripts are written in Bash, so executing and displaying the output to the shell is fairly easy. I know it's kind of ironic, but I didn't want to spend time making my own scripting language as it would consume a lot of time and wouldn't be very beneficial, at least for now.\n\n## Installation Script\n\nInstead of having to download the whole project and compile it yourself, I made a brief installation script that does this for you. Additionally, it creates the init script with a default message and manages all the executable permissions so that you can directly execute the `oxsh` program and be ready to go.\n\n## What Now?\n\nI think this will be the last post of the shell series, as it has achieved its goal: helping me learn Rust and understand it better. I might make a new post in the future expanding the project, but I'm not sure about it yet.\n\nI also want to focus on other things, like `OpenGL` or `SDL2`. So, I think I will start a new project to work on that, as graphic displays are something I wanted to learn since before starting this project. The only problem was that I wasn't familiar with the language itself, and I honestly didn't want to do it in **C++** or **C** because of memory insecurities. But who knows, maybe I will have to, especially with `OpenGL` or other 3D APIs.\n\nSo, I'll see you in the next project!";
						const data = {title:"Building a Unix-shell in Rust - Part 4",date:new Date(1722816000000),tags:["rust"],draft:false,summary:"In this post, we switched from Termion to Rustyline, added command history, implemented an init script, and created an installation script, enhancing our Rust shell's usability and functionality.",author:{slug:"david",collection:"author"},customLayout:"PostLayout",customSlug:"building-a-unixshell-in-rust-part-4"};
						const _internal = {
							type: 'content',
							filePath: "C:/Users/david/Desktop/portfolio/src/content/blog/building-a-unixshell-in-rust-part-4.md",
							rawData: "\ntitle: Building a Unix-shell in Rust - Part 4\ndate: '2024-08-05'\ntags: ['rust']\ndraft: false\nsummary: In this post, we switched from Termion to Rustyline, added command history, implemented an init script, and created an installation script, enhancing our Rust shell's usability and functionality.\nauthor: david\ncustomLayout: PostLayout\ncustomSlug: building-a-unixshell-in-rust-part-4",
						};

export { _internal, body, collection, data, id, slug };
