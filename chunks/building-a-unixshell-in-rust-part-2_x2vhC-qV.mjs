const id = "building-a-unixshell-in-rust-part-2.md";
						const collection = "blog";
						const slug = "building-a-unixshell-in-rust-part-2";
						const body = "\r\n![banner](../../assets/blog/Shell/2/banner_2.png)\r\n\r\nIn the first post of this series, we laid the groundwork by discussing what a shell is and how it works. If you missed it, I suggest starting from there to get the full picture. Now, let's dive into the next steps: reading user input, parsing that input into commands, and classifying those commands to execute the appropriate actions.\r\n\r\n## Reading User Input\r\n\r\nTo start, we need our shell to read user input. This is the first step in our REPL (Read-Eval-Print-Loop) process. Here's how we can achieve this in Rust:\r\n\r\n```rust\r\nuse std::io::{stdin, stdout, Write};\r\n\r\nuse anyhow::Result;\r\n\r\nfn main() -> Result<()> {\r\n    loop {\r\n        // use the `>` character as the prompt\r\n        // need to explicitly flush this to ensure it prints before read_line\r\n        print!(\"> \");\r\n        stdout().flush()?;\r\n\r\n        let mut input = String::new();\r\n        stdin().read_line(&mut input).unwrap();\r\n    }\r\n\r\n    Ok(())\r\n}\r\n```\r\n\r\n### Breaking It Down\r\n\r\n1. **Prompting the User:** We use the `>` character as the prompt. This signals to the user that the shell is ready for input.\r\n\r\n2. **Flushing stdout:** `stdout().flush()?;` ensures that the prompt is printed immediately, not buffered. This is crucial for a good user experience.\r\n\r\n3. **Reading Input:** We read the user input into a mutable `String` variable called `input` using `stdin().read_line(&mut input).unwrap();`. Even though this aproach of reading the user input is very bare bones, as the user cannot edit it while typing, not having the command history, etc. It is sufficient for now and it will be expanded in the future.\r\n\r\nBy this point, we can display a prompt and capture user input. Let's move on to parsing this input.\r\n\r\n## Parsing the Input into Commands\r\n\r\nOnce we have the user input, we need to parse it into a command and its arguments. This helps us determine what action to take.\r\n\r\nFirst, we trim the input using `input.trim()`, which removes any leading or trailing whitespace from the input string. Next, we split the input using `split_ascii_whitespace()`, which splits the input into an iterator of substrings separated by ASCII whitespace. To extract the command, we use `parts.next()`, which retrieves the first substring. If there's no command (empty input), the loop continues. Finally, we extract the arguments by capturing the remaining substrings as the command's arguments with `let args = parts;`.\r\n\r\nHere is the code that does this process:\r\n\r\n```rust\r\nlet mut parts = input.trim().split_ascii_whitespace();\r\nlet command;\r\n\r\nmatch parts.next() {\r\n    Some(com) => command = com,\r\n    None => continue,  // continue if no command provided\r\n}\r\n\r\nlet args = parts;\r\n```\r\n\r\n## Classifying Commands\r\n\r\nWith the command and arguments parsed, we need to classify and handle them appropriately.\r\n\r\nTo do this, we pass the command into a match block and check if it matches a built-in command. If it doesn't, we assume the command is external and execute it. If it turns out not to be a correct command, we display an error message and restart the loop.\r\n\r\n```rust\r\nmatch command {\r\n    \"cd\" => cd(args),\r\n    \"exit\" => break,\r\n    command => {\r\n        let child = Command::new(command)\r\n            .args(args)\r\n            .spawn();\r\n\r\n        match child {\r\n            Ok(mut child) => { child.wait()?; },\r\n            Err(e) => eprintln!(\"{}\", e)\r\n        };\r\n    }\r\n}\r\n```\r\n\r\nFor external commands, `Command::new(command).args(args).spawn()` tries to execute them. If the command executes successfully, `child.wait()?` waits for it to finish.\r\n\r\nIf the command is a built-in one, it is necessary to create a function that implements its functionality and call it with the arguments as parameters, like the `cd` function in the code above.\r\n\r\n## Conclusion\r\n\r\nWe've covered a lot in this post, from reading user input to parsing it into commands and arguments, and finally classifying and executing those commands. Our shell is taking shape, and we now have a basic REPL loop that can handle both built-in and external commands.\r\n\r\nIn the next post, we'll dive deeper into implementing more built-in commands and improving the user experience. Stay tuned, and happy coding!\r\n\r\n## Next Steps\r\n\r\nIn the next post, we'll focus on refactoring the code to improve readability, maintainability, and extend functionality. Stay tuned!";
						const data = {title:"Building a Unix-shell in Rust - Part 2",date:new Date(1722038400000),tags:["rust"],draft:false,summary:"In this second part of the series on building a Unix shell in Rust, we dive into the essential steps of reading user input, parsing it into commands, and classifying those commands for execution.",author:{slug:"david",collection:"author"},customLayout:"PostLayout",customSlug:"building-a-unixshell-in-rust-part-2"};
						const _internal = {
							type: 'content',
							filePath: "C:/Users/david/Desktop/portfolio/src/content/blog/building-a-unixshell-in-rust-part-2.md",
							rawData: "\r\ntitle: \"Building a Unix-shell in Rust - Part 2\"\r\ndate: '2024-07-27'\r\ntags: ['rust']\r\ndraft: false\r\nsummary: In this second part of the series on building a Unix shell in Rust, we dive into the essential steps of reading user input, parsing it into commands, and classifying those commands for execution.\r\nauthor: david\r\ncustomLayout: PostLayout\r\ncustomSlug: building-a-unixshell-in-rust-part-2\r",
						};

export { _internal, body, collection, data, id, slug };
