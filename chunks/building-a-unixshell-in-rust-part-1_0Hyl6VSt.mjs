const id = "building-a-unixshell-in-rust-part-1.md";
						const collection = "blog";
						const slug = "building-a-unixshell-in-rust-part-1";
						const body = "\r\n![banner](../../assets/blog/Shell/1/ShellPhoto.png)\r\n\r\nThroughout this year and last one, I haven't stopped hearing how amazing Rust is and how awesome its developer experience is. In addition, Rust was ranked as one of the most loved programming languages in 2023. So, it was time to learn it and see why people praise it so much.\r\n\r\nTo do that, I decided to build a Unix shell in Rust. It seems like a good starter project, and I use the terminal and shell commands a lot in my day-to-day tasks. It seemed like the perfect idea—not only to learn the language but also to understand how a shell works and what makes them so useful.\r\n\r\n## What's a Shell?\r\n\r\nBefore we dive into development, it's important to know what a shell is. There's often confusion among people when differentiating between a Shell, Terminal, and Prompt.\r\n\r\nHere's a brief explanation of each concept:\r\n\r\n- **Terminal:** The terminal emulator (often just called terminal) is \"the window\" that displays the characters you type and sends them to the shell. It also shows the shell's output in the window.\r\n- **Shell:** A shell is a program that allows you to control your computer more easily than manually doing it. It's responsible for executing the commands you type.\r\n- **Prompt:** The prompt is just the line where you write the instructions for the shell. It's what you can mainly customize to your liking via third-party scripts, such as oh-my-posh, oh-my-zsh, etc.\r\n\r\nSome examples of Unix shells, like the kind we're making, are:\r\n\r\n- Bourne-shell (sh)\r\n- bash\r\n- zsh\r\n- fish\r\n\r\nOr the Windows-specific shells, which are confusingly both the shell and terminal emulator:\r\n\r\n- Command Prompt (cmd)\r\n- PowerShell\r\n\r\nExamples of terminal emulators:\r\n\r\n- xterm\r\n- rxvt\r\n- Alacritty (which is also written in Rust)\r\n- iTerm\r\n- Terminal.app\r\n- Command Prompt (cmd)\r\n- PowerShell\r\n\r\nThe goal is to write a shell similar to bash, as it's the one I've used the most. I've also used zsh, but not as extensively as bash.\r\n\r\n## How Does a Shell Work?\r\n\r\nSo now that we know what a shell is, how does it work? Well, a shell uses what is called a **REPL (Read-Eval-Print-Loop)**. This means you first type a command in the prompt, which is usually just a dollar sign (`$`). Then you hit enter to translate the command into an action. The shell executes it, and the output prints to the screen. This loop repeats forever, or until the user closes the terminal.\r\n\r\nHere is a diagram that explains more extensively what happens in the shell.\r\n![Diagram_shell](../../assets/blog/Shell/1/shell_diagram.webp)\r\n\r\nLets see this in action with an example using `ls`:\r\n\r\n1. First, we type the command we want to execute, in this case, `ls`:\r\n\r\n    ```bash\r\n    / ❯ ls \r\n    ```\r\n\r\n2. We hit enter, and the shell executes the command and its output is displayed:\r\n\r\n    ```bash\r\n    / ❯ ls \r\n    bin   dev  home  lib    lib64   lost+found  mnt  proc  run   snap  sys  usr\r\n    boot  etc  init  lib32  libx32  media       opt  root  sbin  srv   tmp  var\r\n    ```\r\n\r\n3. At the end of the output, the loop repeats by letting you type another command:\r\n\r\n    ```bash\r\n    / ❯ ls \r\n    bin   dev  home  lib    lib64   lost+found  mnt  proc  run   snap  sys  usr\r\n    boot  etc  init  lib32  libx32  media       opt  root  sbin  srv   tmp  var\r\n    / ❯  \r\n    ```\r\n\r\n## Architecture of Our Shell\r\n\r\nBefore starting to write code, it's necessary to have everything well organized to be as efficient as possible when programming and to have a general view of the product and how it will be done.\r\n\r\n### Execute Initial Scripts and Shell Configurations\r\n\r\nBefore starting to read user input, the shell has to read the configuration file. This is done to customize the shell to each user's preferences. \r\n\r\nAlthough this step will be done later in the series, once all the base of the shell has been established, it is important to keep in mind that customization is crucial.\r\n\r\n### Read User Input\r\n\r\nAfter the initial configuration, we start the general loop by reading the user input. Most shells print a symbol to signal to the user that they can input a command.\r\n\r\nNext, we need to analyze the user input to determine if it is a built-in command or an external one.\r\n\r\nThe difference between them is simple: a built-in command is directly handled by the shell itself, instead of executing an external process. In other words, it's a function call within the shell's code. An external command is either a binary in one of the directories in your PATH or located in a filesystem path (relative or absolute).\r\n\r\n| **Some Built-in Commands** | **Some External Commands** |\r\n|:--------------------------:|:--------------------------:|\r\n| `cd`, `help`, `echo`       | `grep`, `wget`, `curl`     |\r\n\r\nThe most popular example of a built-in command is `cd`. The reason it must be built-in is that an external program can't change the environment of the current working directory, so it must be changed by the shell itself. A more in-depth explanation can be found in [this link](https://unix.stackexchange.com/a/38809).\r\n\r\n### Then We Execute\r\n\r\nWhen we use a command that calls a built-in, we simply pass the arguments to the function and return to the start of the loop when it completes.\r\n\r\n#### And When We Call an Executable?\r\n\r\nWe need to make a fork syscall, that is, create a new process for the executable to run in, so it can have its own memory space and manage its interactions with the operating system (The shell is still the parent process).\r\n\r\n### Then We Process\r\n\r\nThis is when we cause side effects to the system.\r\n\r\nWe want to provide feedback to the user to let them know the results of this process. To keep this simple, we will only consider returning text to the user, as we are providing commands as text.\r\n\r\nOur shell process has at least 3 file descriptors for passing input or receiving output: Stdin, Stdout, and Stderr.\r\n\r\nAfter the process is complete, any output should be printed to the screen, via stdout or stderr.\r\n\r\n### Lastly, We Loop\r\n\r\nControl returns to the user. The default user prompt prints as a visual cue (along with the typical blinking cursor), and we should be able to enter another command.\r\n\r\n## Time to Code\r\n\r\nNow that we have set the record straight on how the shell is going to work, we can start coding the basics. But that will be explained in the next post. See you next time!";
						const data = {title:"Building a Unix-shell in Rust - Part 1",date:new Date(1721606400000),tags:["rust"],draft:false,summary:"This is the first part of a series were I'll build a Unix shell in rust.",author:{slug:"david",collection:"author"},customLayout:"PostLayout",customSlug:"building-a-unixshell-in-rust-part-1"};
						const _internal = {
							type: 'content',
							filePath: "C:/Users/david/Desktop/portfolio/src/content/blog/building-a-unixshell-in-rust-part-1.md",
							rawData: "\r\ntitle: \"Building a Unix-shell in Rust - Part 1\"\r\ndate: '2024-07-22'\r\ntags: ['rust']\r\ndraft: false\r\nsummary: This is the first part of a series were I'll build a Unix shell in rust.\r\nauthor: david\r\ncustomLayout: PostLayout\r\ncustomSlug: building-a-unixshell-in-rust-part-1\r",
						};

export { _internal, body, collection, data, id, slug };
