import { d as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML, s as spreadAttributes } from './astro_JQFs6gbx.mjs';
import { g as getImage } from './prerender_JWpf4pTo.mjs';
import 'clsx';

const Astro__dDpJR = new Proxy({"src":"/_astro/banner_4.UR6Nitxz.jpg","width":5616,"height":3744,"format":"jpg"}, {
						get(target, name, receiver) {
							if (name === 'clone') {
								return structuredClone(target);
							}
							if (name === 'fsPath') {
								return "C:/Users/david/Desktop/portfolio/src/assets/blog/Shell/4/banner_4.jpg";
							}
							globalThis.astroAsset.referencedImages.add("C:/Users/david/Desktop/portfolio/src/assets/blog/Shell/4/banner_4.jpg");
							return target[name];
						}
					});

const images = async function(html) {
					const imageSources = {};
					{
											const regex = new RegExp('__ASTRO_IMAGE_="([^"]*' + "\\.\\./\\.\\./assets/blog/Shell/4/banner_4\\.jpg" + '[^"]*)"', 'g');
											let match;
											let occurrenceCounter = 0;
											while ((match = regex.exec(html)) !== null) {
													const matchKey = "../../assets/blog/Shell/4/banner_4.jpg" + '_' + occurrenceCounter;
													const imageProps = JSON.parse(match[1].replace(/&#x22;/g, '"'));
													const { src, ...props } = imageProps;

													imageSources[matchKey] = await getImage({src: Astro__dDpJR, ...props});
													occurrenceCounter++;
											}
									}
					return imageSources;
			};

			async function updateImageReferences(html) {
				return images(html).then((imageSources) => {
						return html.replaceAll(/__ASTRO_IMAGE_="([^"]+)"/gm, (full, imagePath) => {
								const decodedImagePath = JSON.parse(imagePath.replace(/&#x22;/g, '"'));
		
								// Use the 'index' property for each image occurrence
								const srcKey = decodedImagePath.src + '_' + decodedImagePath.index;
		
								if (imageSources[srcKey].srcSet && imageSources[srcKey].srcSet.values.length > 0) {
										imageSources[srcKey].attributes.srcset = imageSources[srcKey].srcSet.attribute;
								}
		
								const { index, ...attributesWithoutIndex } = imageSources[srcKey].attributes;
		
								return spreadAttributes({
										src: imageSources[srcKey].src,
										...attributesWithoutIndex,
								});
						});
				});
		}
		

		// NOTE: This causes a top-level await to appear in the user's code, which can break very easily due to a Rollup
	  // bug and certain adapters not supporting it correctly. See: https://github.com/rollup/rollup/issues/4708
	  // Tread carefully!
			const html = await updateImageReferences("<p><img __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/blog/Shell/4/banner_4.jpg&#x22;,&#x22;alt&#x22;:&#x22;banner&#x22;,&#x22;index&#x22;:0}\"></p>\n<p>In the last post, we tackled formatting code, organizing files, handling errors, adding pipes, and using Termion for input. This time, we’ll be discussing the switch from Termion to Rustyline, adding a command history feature, implementing an init script, and creating an installation script. Let’s dive in!</p>\n<h2 id=\"changed-from-termion-to-rustyline\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#changed-from-termion-to-rustyline\"><span class=\"icon icon-link\"></span></a>Changed from Termion to Rustyline</h2>\n<p>Given the difficulties with <strong>Termion</strong> and since I don’t need to create a complex terminal layout, I decided to switch to <strong>Rustyline</strong>. This crate allows you to do simple things like letting the user edit the input, having a customizable prompt, command history, and other technical features.</p>\n<p>This change was not only beneficial in terms of UI and features but also in performance and code readability. Instead of configuring the terminal layout from scratch, which is great for complex layouts, Rustyline provides a basic layout and events you can listen to before receiving the input, something the standard library lacks.</p>\n<p>Here is the <code>read_input</code> function implemented with Rustyline. It’s much simpler and more readable than with Termion:</p>\n<div class=\"remark-code-title\">prompt.rs</div>\n<pre class=\"language-rust\"><code is:raw=\"\" class=\"language-rust\"><span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">read_input</span><span class=\"token punctuation\">(</span>rl<span class=\"token punctuation\">:</span> <span class=\"token operator\">&#x26;</span><span class=\"token keyword\">mut</span> <span class=\"token class-name\">Editor</span><span class=\"token operator\">&#x3C;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token namespace\">rustyline<span class=\"token punctuation\">::</span>history<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">FileHistory</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">Option</span><span class=\"token operator\">&#x3C;</span><span class=\"token class-name\">String</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Read user input from the console using the rustyline library</span>\n    <span class=\"token keyword\">match</span> rl<span class=\"token punctuation\">.</span><span class=\"token function\">readline</span><span class=\"token punctuation\">(</span><span class=\"token function\">get_prompt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">as_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// If the input was successfully read, add it to the history and return it</span>\n        <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> rl<span class=\"token punctuation\">.</span><span class=\"token function\">add_history_entry</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">.</span><span class=\"token function\">as_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">is_err</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Failed to add input to history\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span><span class=\"token namespace\">rustyline<span class=\"token punctuation\">::</span>error<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">ReadlineError</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">Interrupted</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Interrupted process: {:?}\"</span><span class=\"token punctuation\">,</span> <span class=\"token namespace\">rustyline<span class=\"token punctuation\">::</span>error<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">ReadlineError</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">Interrupted</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">None</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// If there was an error reading the input, print the error and return an empty String</span>\n        <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error: {:?}\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">None</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"history-command\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#history-command\"><span class=\"icon icon-link\"></span></a>History Command</h2>\n<p>Just like Bash has the <code>history</code> command, which allows you to view and manipulate the command history, I wanted to implement a similar feature in our shell. This enables users to customize their command history.</p>\n<p>Adding this feature was straightforward since Rustyline already has built-in support for command history. The implementation of the history command was also surprisingly simple. It doesn’t do as much as the Bash version, but it is sufficient. The history file is stored in the home directory with the name <code>.oxsh_history</code>,” similar to Bash.</p>\n<h2 id=\"init-script\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#init-script\"><span class=\"icon icon-link\"></span></a>Init Script</h2>\n<p>I also added the possibility to read an initial script when starting the shell. This script has to be situated in the home directory of the user using the shell, but in the future, I might implement global init scripts.</p>\n<p>These scripts are written in Bash, so executing and displaying the output to the shell is fairly easy. I know it’s kind of ironic, but I didn’t want to spend time making my own scripting language as it would consume a lot of time and wouldn’t be very beneficial, at least for now.</p>\n<h2 id=\"installation-script\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#installation-script\"><span class=\"icon icon-link\"></span></a>Installation Script</h2>\n<p>Instead of having to download the whole project and compile it yourself, I made a brief installation script that does this for you. Additionally, it creates the init script with a default message and manages all the executable permissions so that you can directly execute the <code>oxsh</code> program and be ready to go.</p>\n<h2 id=\"what-now\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#what-now\"><span class=\"icon icon-link\"></span></a>What Now?</h2>\n<p>I think this will be the last post of the shell series, as it has achieved its goal: helping me learn Rust and understand it better. I might make a new post in the future expanding the project, but I’m not sure about it yet.</p>\n<p>I also want to focus on other things, like <code>OpenGL</code> or <code>SDL2</code>. So, I think I will start a new project to work on that, as graphic displays are something I wanted to learn since before starting this project. The only problem was that I wasn’t familiar with the language itself, and I honestly didn’t want to do it in <strong>C++</strong> or <strong>C</strong> because of memory insecurities. But who knows, maybe I will have to, especially with <code>OpenGL</code> or other 3D APIs.</p>\n<p>So, I’ll see you in the next project!</p>");
	

				const frontmatter = {"title":"Building a Unix-shell in Rust - Part 4","date":"2024-08-05","tags":["rust"],"draft":false,"summary":"In this post, we switched from Termion to Rustyline, added command history, implemented an init script, and created an installation script, enhancing our Rust shell's usability and functionality.","author":"david","customLayout":"PostLayout","customSlug":"building-a-unixshell-in-rust-part-4"};
				const file = "C:/Users/david/Desktop/portfolio/src/content/blog/building-a-unixshell-in-rust-part-4.md";
				const url = undefined;
				function rawContent() {
					return "\n![banner](../../assets/blog/Shell/4/banner_4.jpg)\n\nIn the last post, we tackled formatting code, organizing files, handling errors, adding pipes, and using Termion for input. This time, we'll be discussing the switch from Termion to Rustyline, adding a command history feature, implementing an init script, and creating an installation script. Let's dive in!\n\n## Changed from Termion to Rustyline\n\nGiven the difficulties with **Termion** and since I don't need to create a complex terminal layout, I decided to switch to **Rustyline**. This crate allows you to do simple things like letting the user edit the input, having a customizable prompt, command history, and other technical features.\n\nThis change was not only beneficial in terms of UI and features but also in performance and code readability. Instead of configuring the terminal layout from scratch, which is great for complex layouts, Rustyline provides a basic layout and events you can listen to before receiving the input, something the standard library lacks.\n\nHere is the `read_input` function implemented with Rustyline. It's much simpler and more readable than with Termion:\n\n```rust:prompt.rs\npub fn read_input(rl: &mut Editor<(), rustyline::history::FileHistory>) -> Option<String> {\n    // Read user input from the console using the rustyline library\n    match rl.readline(get_prompt().as_str()) {\n        // If the input was successfully read, add it to the history and return it\n        Ok(input) => {\n            if rl.add_history_entry(input.as_str()).is_err() {\n                println!(\"Failed to add input to history\");\n            }\n\n            Some(input)\n        }\n        Err(rustyline::error::ReadlineError::Interrupted) => {\n            println!(\"Interrupted process: {:?}\", rustyline::error::ReadlineError::Interrupted);\n            None\n        }\n        // If there was an error reading the input, print the error and return an empty String\n        Err(err) => {\n            println!(\"Error: {:?}\", err);\n            None\n        }\n    }\n}\n```\n\n## History Command\n\nJust like Bash has the `history` command, which allows you to view and manipulate the command history, I wanted to implement a similar feature in our shell. This enables users to customize their command history.\n\nAdding this feature was straightforward since Rustyline already has built-in support for command history. The implementation of the history command was also surprisingly simple. It doesn't do as much as the Bash version, but it is sufficient. The history file is stored in the home directory with the name `.oxsh_history`,\" similar to Bash.\n\n## Init Script\n\nI also added the possibility to read an initial script when starting the shell. This script has to be situated in the home directory of the user using the shell, but in the future, I might implement global init scripts.\n\nThese scripts are written in Bash, so executing and displaying the output to the shell is fairly easy. I know it's kind of ironic, but I didn't want to spend time making my own scripting language as it would consume a lot of time and wouldn't be very beneficial, at least for now.\n\n## Installation Script\n\nInstead of having to download the whole project and compile it yourself, I made a brief installation script that does this for you. Additionally, it creates the init script with a default message and manages all the executable permissions so that you can directly execute the `oxsh` program and be ready to go.\n\n## What Now?\n\nI think this will be the last post of the shell series, as it has achieved its goal: helping me learn Rust and understand it better. I might make a new post in the future expanding the project, but I'm not sure about it yet.\n\nI also want to focus on other things, like `OpenGL` or `SDL2`. So, I think I will start a new project to work on that, as graphic displays are something I wanted to learn since before starting this project. The only problem was that I wasn't familiar with the language itself, and I honestly didn't want to do it in **C++** or **C** because of memory insecurities. But who knows, maybe I will have to, especially with `OpenGL` or other 3D APIs.\n\nSo, I'll see you in the next project!";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"changed-from-termion-to-rustyline","text":"Changed from Termion to Rustyline"},{"depth":2,"slug":"history-command","text":"History Command"},{"depth":2,"slug":"init-script","text":"Init Script"},{"depth":2,"slug":"installation-script","text":"Installation Script"},{"depth":2,"slug":"what-now","text":"What Now?"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
