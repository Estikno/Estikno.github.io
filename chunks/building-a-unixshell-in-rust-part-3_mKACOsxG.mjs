import { d as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML, s as spreadAttributes } from './astro_JQFs6gbx.mjs';
import { g as getImage } from './prerender_JWpf4pTo.mjs';
import 'clsx';

const Astro__Z1Boi8s = new Proxy({"src":"/_astro/banner_shell_3.tr99Gx5T.jpg","width":3984,"height":2656,"format":"jpg"}, {
						get(target, name, receiver) {
							if (name === 'clone') {
								return structuredClone(target);
							}
							if (name === 'fsPath') {
								return "C:/Users/david/Desktop/portfolio/src/assets/blog/Shell/3/banner_shell_3.jpg";
							}
							globalThis.astroAsset.referencedImages.add("C:/Users/david/Desktop/portfolio/src/assets/blog/Shell/3/banner_shell_3.jpg");
							return target[name];
						}
					});

const images = async function(html) {
					const imageSources = {};
					{
											const regex = new RegExp('__ASTRO_IMAGE_="([^"]*' + "\\.\\./\\.\\./assets/blog/Shell/3/banner_shell_3\\.jpg" + '[^"]*)"', 'g');
											let match;
											let occurrenceCounter = 0;
											while ((match = regex.exec(html)) !== null) {
													const matchKey = "../../assets/blog/Shell/3/banner_shell_3.jpg" + '_' + occurrenceCounter;
													const imageProps = JSON.parse(match[1].replace(/&#x22;/g, '"'));
													const { src, ...props } = imageProps;

													imageSources[matchKey] = await getImage({src: Astro__Z1Boi8s, ...props});
													occurrenceCounter++;
											}
									}
					return imageSources;
			};

			async function updateImageReferences(html) {
				return images(html).then((imageSources) => {
						return html.replaceAll(/__ASTRO_IMAGE_="([^"]+)"/gm, (full, imagePath) => {
								const decodedImagePath = JSON.parse(imagePath.replace(/&#x22;/g, '"'));
		
								// Use the 'index' property for each image occurrence
								const srcKey = decodedImagePath.src + '_' + decodedImagePath.index;
		
								if (imageSources[srcKey].srcSet && imageSources[srcKey].srcSet.values.length > 0) {
										imageSources[srcKey].attributes.srcset = imageSources[srcKey].srcSet.attribute;
								}
		
								const { index, ...attributesWithoutIndex } = imageSources[srcKey].attributes;
		
								return spreadAttributes({
										src: imageSources[srcKey].src,
										...attributesWithoutIndex,
								});
						});
				});
		}
		

		// NOTE: This causes a top-level await to appear in the user's code, which can break very easily due to a Rollup
	  // bug and certain adapters not supporting it correctly. See: https://github.com/rollup/rollup/issues/4708
	  // Tread carefully!
			const html = await updateImageReferences("<p><img __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/blog/Shell/3/banner_shell_3.jpg&#x22;,&#x22;alt&#x22;:&#x22;Banner&#x22;,&#x22;index&#x22;:0}\"></p>\n<p>In the last post, we covered how to read user input, parse it into commands, and classify those commands for execution. Now, it’s time to refine our code, organize it better, and add some new features. Let’s dive into formatting our code, organizing files, handling errors, adding pipes, and using Termion for input.</p>\n<h2 id=\"formatting-code\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#formatting-code\"><span class=\"icon icon-link\"></span></a>Formatting Code</h2>\n<p>One of the key aspects of maintaining clean and readable code is formatting. Consistent formatting helps others (and your future self) understand the code more easily. While Rust has tools like <code>rustfmt</code> to help automate this process, it’s important to adopt good practices and keep your code neat.</p>\n<h2 id=\"organizing-files-and-adding-error-handling\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#organizing-files-and-adding-error-handling\"><span class=\"icon icon-link\"></span></a>Organizing Files and Adding Error Handling</h2>\n<p>To improve our shell, I reorganized the files and added better error handling. Here’s what I did:</p>\n<ul>\n<li>Moved the content of <code>cd.rs</code> from <code>commands/cd.rs</code> to <code>commands.rs</code>.</li>\n<li>Imported <code>anyhow</code> for better error handling and to use the convenient <code>?</code> operator instead of the default <code>Result</code> object in Rust.</li>\n</ul>\n<p>Here’s the updated <code>main.rs</code> with <code>anyhow</code>:</p>\n<div class=\"remark-code-title\">main.rs</div>\n<pre class=\"language-rust\"><code is:raw=\"\" class=\"language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">anyhow<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Result</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">Result</span><span class=\"token operator\">&#x3C;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//...Boring code...</span>\n    <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"adding-simple-pipes\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#adding-simple-pipes\"><span class=\"icon icon-link\"></span></a>Adding Simple Pipes</h2>\n<p>Pipes are a fundamental feature in Unix shells, allowing the output of one command to be used as the input for another. I’ve added the possibility to use pipes in our shell. They are basic for now but will be expanded in the future.</p>\n<p>Here’s the code snippet for handling pipes:</p>\n<pre class=\"language-rust\"><code is:raw=\"\" class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> commands <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" | \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">peekable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token keyword\">let</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> commands<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// everything after the first whitespace character</span>\n    <span class=\"token comment\">//     is interpreted as args to the command</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> parts <span class=\"token operator\">=</span> command<span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split_ascii_whitespace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> command <span class=\"token operator\">=</span> <span class=\"token keyword\">match</span> parts<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> command<span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">None</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">continue</span> <span class=\"token lifetime-annotation symbol\">'main_loop</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// break if no command provided</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> args <span class=\"token operator\">=</span> parts<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//...code that handles the command execution...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"explanation\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#explanation\"><span class=\"icon icon-link\"></span></a>Explanation</h3>\n<ul>\n<li><strong>Splitting Commands:</strong> <code>input.trim().split(\" | \").peekable()</code> splits the input string by the pipe (<code>|</code>) symbol and makes it an iterator.</li>\n<li><strong>Iterating Through Commands:</strong> The <code>while let</code> loop iterates through each command, splitting it into parts (command and arguments).</li>\n</ul>\n<h2 id=\"using-termion-for-input\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#using-termion-for-input\"><span class=\"icon icon-link\"></span></a>Using Termion for Input</h2>\n<p>Instead of using the standard <code>stdin</code> library for input, the shell now uses Termion in raw mode. This change sets us up to add keybindings and handle special characters more easily.</p>\n<p>Here’s the updated code in <code>prompt.rs</code>:</p>\n<div class=\"remark-code-title\">prompt.rs</div>\n<pre class=\"language-rust\"><code is:raw=\"\" class=\"language-rust\"><span class=\"token comment\">// termion</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">termion<span class=\"token punctuation\">::</span>event<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Key</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">termion<span class=\"token punctuation\">::</span>input<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">TermRead</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">termion<span class=\"token punctuation\">::</span>raw<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">IntoRawMode</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">termion<span class=\"token punctuation\">::</span>cursor<span class=\"token punctuation\">::</span></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">DetectCursorPos</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">read_input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">Result</span><span class=\"token operator\">&#x3C;</span><span class=\"token class-name\">String</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> input <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// read input</span>\n    <span class=\"token keyword\">let</span> stdin <span class=\"token operator\">=</span> <span class=\"token function\">stdin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> stdout <span class=\"token operator\">=</span> <span class=\"token function\">stdout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">into_raw_mode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//^-- we go into raw mode to manage the terminal output and input manually</span>\n    <span class=\"token keyword\">let</span> cursor_pos <span class=\"token operator\">=</span> stdout<span class=\"token punctuation\">.</span><span class=\"token function\">cursor_pos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> index<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token macro property\">write!</span><span class=\"token punctuation\">(</span>stdout<span class=\"token punctuation\">,</span> <span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> <span class=\"token namespace\">cursor<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Hide</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n    <span class=\"token macro property\">write!</span><span class=\"token punctuation\">(</span>stdout<span class=\"token punctuation\">,</span> <span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> <span class=\"token namespace\">cursor<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Goto</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> cursor_pos<span class=\"token number\">.1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n    stdout<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> k <span class=\"token keyword\">in</span> stdin<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">match</span> k<span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">Key</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">Char</span><span class=\"token punctuation\">(</span><span class=\"token char\">'\\n'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">,</span>\n            <span class=\"token class-name\">Key</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">Char</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">//...Receives a normal character, so we apply it to the input string...</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token class-name\">Key</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">Backspace</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">//...The user is trying to remove a character from the input, so we do it...</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            _ <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// Remains to add special characters: Control+C, Control+D, arrow keys, etc.</span>\n        <span class=\"token punctuation\">}</span>\n        stdout<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token macro property\">write!</span><span class=\"token punctuation\">(</span>stdout<span class=\"token punctuation\">,</span> <span class=\"token string\">\"{}{}\"</span><span class=\"token punctuation\">,</span> <span class=\"token namespace\">cursor<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Show</span><span class=\"token punctuation\">,</span> <span class=\"token namespace\">termion<span class=\"token punctuation\">::</span>clear<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">CurrentLine</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n    stdout<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"explanation-1\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#explanation-1\"><span class=\"icon icon-link\"></span></a>Explanation</h3>\n<ul>\n<li><strong>Entering Raw Mode:</strong> <code>stdout().into_raw_mode().unwrap();</code> switches the terminal into raw mode, allowing us to handle input and output manually.</li>\n<li><strong>Hiding the Cursor:</strong> <code>write!(stdout, \"{}\", cursor::Hide)?;</code> hides the real cursor and positions it at the beginning.</li>\n<li><strong>Reading Input:</strong> The loop reads each key and handles characters and backspaces appropriately.</li>\n</ul>\n<h3 id=\"why-termion\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#why-termion\"><span class=\"icon icon-link\"></span></a>Why Termion?</h3>\n<p>I chose <strong>Termion</strong> over <strong>Crossterm</strong> because Termion is more Unix-focused, which aligns with our shell’s Unix base. Although Crossterm supports Windows, it is more complex to use. Since our shell won’t work on Windows regardless, Termion is the better choice.</p>\n<h3 id=\"future-improvements\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#future-improvements\"><span class=\"icon icon-link\"></span></a>Future Improvements</h3>\n<p>Due to some issues with Termion, the cursor has to be hidden and placed in the first column to ensure the input is written correctly. I added a “fake” cursor to mimic the real one while typing until I find a better solution. This workaround is temporary, but necessary for now.</p>\n<h2 id=\"whats-next\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#whats-next\"><span class=\"icon icon-link\"></span></a>What’s Next?</h2>\n<p>Next, we’ll finish the basic input handling with Termion to accept more commands (e.g., Control+C) and use the up and down arrow keys to navigate through the command history. We’ll also add a built-in command to manage the command history and write some tests to ensure everything works correctly, especially the command parser, which is crucial.</p>\n<p>Stay tuned for the next post, where we’ll continue improving our shell!</p>");
	

				const frontmatter = {"title":"Building a Unix-shell in Rust - Part 3","date":"2024-08-01","tags":["rust"],"draft":false,"summary":"In this post we will format the code and add some input functionality","author":"david","customLayout":"PostLayout","customSlug":"building-a-unixshell-in-rust-part-3"};
				const file = "C:/Users/david/Desktop/portfolio/src/content/blog/building-a-unixshell-in-rust-part-3.md";
				const url = undefined;
				function rawContent() {
					return "\n![Banner](../../assets/blog/Shell/3/banner_shell_3.jpg)\n\nIn the last post, we covered how to read user input, parse it into commands, and classify those commands for execution. Now, it's time to refine our code, organize it better, and add some new features. Let's dive into formatting our code, organizing files, handling errors, adding pipes, and using Termion for input.\n\n## Formatting Code\n\nOne of the key aspects of maintaining clean and readable code is formatting. Consistent formatting helps others (and your future self) understand the code more easily. While Rust has tools like `rustfmt` to help automate this process, it's important to adopt good practices and keep your code neat.\n\n## Organizing Files and Adding Error Handling\n\nTo improve our shell, I reorganized the files and added better error handling. Here's what I did:\n\n- Moved the content of `cd.rs` from `commands/cd.rs` to `commands.rs`.\n- Imported `anyhow` for better error handling and to use the convenient `?` operator instead of the default `Result` object in Rust.\n\nHere's the updated `main.rs` with `anyhow`:\n\n```rust:main.rs\nuse anyhow::Result;\n\nfn main() -> Result<()> {\n    //...Boring code...\n    Ok(())\n}\n```\n\n## Adding Simple Pipes\n\nPipes are a fundamental feature in Unix shells, allowing the output of one command to be used as the input for another. I've added the possibility to use pipes in our shell. They are basic for now but will be expanded in the future.\n\nHere's the code snippet for handling pipes:\n\n```rust\nlet mut commands = input.trim().split(\" | \").peekable();\n\nwhile let Some(command) = commands.next() {\n    // everything after the first whitespace character\n    //     is interpreted as args to the command\n    let mut parts = command.trim().split_ascii_whitespace();\n    let command = match parts.next() {\n        Some(command) => command,\n        None => { continue 'main_loop; },  // break if no command provided\n    };\n    let args = parts;\n\n    //...code that handles the command execution...\n}\n```\n\n### Explanation\n\n-   **Splitting Commands:** `input.trim().split(\" | \").peekable()` splits the input string by the pipe (`|`) symbol and makes it an iterator.\n-   **Iterating Through Commands:** The `while let` loop iterates through each command, splitting it into parts (command and arguments).\n\n## Using Termion for Input\n\nInstead of using the standard `stdin` library for input, the shell now uses Termion in raw mode. This change sets us up to add keybindings and handle special characters more easily.\n\nHere's the updated code in `prompt.rs`:\n\n```rust:prompt.rs\n// termion\nuse termion::event::Key;\nuse termion::input::TermRead;\nuse termion::raw::IntoRawMode;\nuse termion::cursor::{self, DetectCursorPos};\n\npub fn read_input() -> Result<String> {\n    let mut input = String::new();\n\n    // read input\n    let stdin = stdin();\n    let mut stdout = stdout().into_raw_mode().unwrap();\n    //^-- we go into raw mode to manage the terminal output and input manually\n    let cursor_pos = stdout.cursor_pos()?;\n    let mut index: usize = 0;\n\n    write!(stdout, \"{}\", cursor::Hide)?;\n    write!(stdout, \"{}\", cursor::Goto(0, cursor_pos.1))?;\n    stdout.flush()?;\n\n    for k in stdin.keys() {\n        match k? {\n            Key::Char('\\n') => break,\n            Key::Char(c) => {\n                //...Receives a normal character, so we apply it to the input string...\n            },\n            Key::Backspace => {\n                //...The user is trying to remove a character from the input, so we do it...\n            },\n            _ => () // Remains to add special characters: Control+C, Control+D, arrow keys, etc.\n        }\n        stdout.flush()?;\n    }\n\n    write!(stdout, \"{}{}\", cursor::Show, termion::clear::CurrentLine)?;\n    stdout.flush()?;\n\n    Ok(input)\n}\n```\n\n### Explanation\n\n-   **Entering Raw Mode:** `stdout().into_raw_mode().unwrap();` switches the terminal into raw mode, allowing us to handle input and output manually.\n-   **Hiding the Cursor:** `write!(stdout, \"{}\", cursor::Hide)?;` hides the real cursor and positions it at the beginning.\n-   **Reading Input:** The loop reads each key and handles characters and backspaces appropriately.\n\n### Why Termion?\n\nI chose **Termion** over **Crossterm** because Termion is more Unix-focused, which aligns with our shell's Unix base. Although Crossterm supports Windows, it is more complex to use. Since our shell won't work on Windows regardless, Termion is the better choice.\n\n### Future Improvements\n\nDue to some issues with Termion, the cursor has to be hidden and placed in the first column to ensure the input is written correctly. I added a \"fake\" cursor to mimic the real one while typing until I find a better solution. This workaround is temporary, but necessary for now.\n\n## What's Next?\n\nNext, we'll finish the basic input handling with Termion to accept more commands (e.g., Control+C) and use the up and down arrow keys to navigate through the command history. We'll also add a built-in command to manage the command history and write some tests to ensure everything works correctly, especially the command parser, which is crucial.\n\nStay tuned for the next post, where we'll continue improving our shell!";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"formatting-code","text":"Formatting Code"},{"depth":2,"slug":"organizing-files-and-adding-error-handling","text":"Organizing Files and Adding Error Handling"},{"depth":2,"slug":"adding-simple-pipes","text":"Adding Simple Pipes"},{"depth":3,"slug":"explanation","text":"Explanation"},{"depth":2,"slug":"using-termion-for-input","text":"Using Termion for Input"},{"depth":3,"slug":"explanation-1","text":"Explanation"},{"depth":3,"slug":"why-termion","text":"Why Termion?"},{"depth":3,"slug":"future-improvements","text":"Future Improvements"},{"depth":2,"slug":"whats-next","text":"What’s Next?"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
