const id = "building-a-unixshell-in-rust-part-3.md";
						const collection = "blog";
						const slug = "building-a-unixshell-in-rust-part-3";
						const body = "\n![Banner](../../assets/blog/Shell/3/banner_shell_3.jpg)\n\nIn the last post, we covered how to read user input, parse it into commands, and classify those commands for execution. Now, it's time to refine our code, organize it better, and add some new features. Let's dive into formatting our code, organizing files, handling errors, adding pipes, and using Termion for input.\n\n## Formatting Code\n\nOne of the key aspects of maintaining clean and readable code is formatting. Consistent formatting helps others (and your future self) understand the code more easily. While Rust has tools like `rustfmt` to help automate this process, it's important to adopt good practices and keep your code neat.\n\n## Organizing Files and Adding Error Handling\n\nTo improve our shell, I reorganized the files and added better error handling. Here's what I did:\n\n- Moved the content of `cd.rs` from `commands/cd.rs` to `commands.rs`.\n- Imported `anyhow` for better error handling and to use the convenient `?` operator instead of the default `Result` object in Rust.\n\nHere's the updated `main.rs` with `anyhow`:\n\n```rust:main.rs\nuse anyhow::Result;\n\nfn main() -> Result<()> {\n    //...Boring code...\n    Ok(())\n}\n```\n\n## Adding Simple Pipes\n\nPipes are a fundamental feature in Unix shells, allowing the output of one command to be used as the input for another. I've added the possibility to use pipes in our shell. They are basic for now but will be expanded in the future.\n\nHere's the code snippet for handling pipes:\n\n```rust\nlet mut commands = input.trim().split(\" | \").peekable();\n\nwhile let Some(command) = commands.next() {\n    // everything after the first whitespace character\n    //     is interpreted as args to the command\n    let mut parts = command.trim().split_ascii_whitespace();\n    let command = match parts.next() {\n        Some(command) => command,\n        None => { continue 'main_loop; },  // break if no command provided\n    };\n    let args = parts;\n\n    //...code that handles the command execution...\n}\n```\n\n### Explanation\n\n-   **Splitting Commands:** `input.trim().split(\" | \").peekable()` splits the input string by the pipe (`|`) symbol and makes it an iterator.\n-   **Iterating Through Commands:** The `while let` loop iterates through each command, splitting it into parts (command and arguments).\n\n## Using Termion for Input\n\nInstead of using the standard `stdin` library for input, the shell now uses Termion in raw mode. This change sets us up to add keybindings and handle special characters more easily.\n\nHere's the updated code in `prompt.rs`:\n\n```rust:prompt.rs\n// termion\nuse termion::event::Key;\nuse termion::input::TermRead;\nuse termion::raw::IntoRawMode;\nuse termion::cursor::{self, DetectCursorPos};\n\npub fn read_input() -> Result<String> {\n    let mut input = String::new();\n\n    // read input\n    let stdin = stdin();\n    let mut stdout = stdout().into_raw_mode().unwrap();\n    //^-- we go into raw mode to manage the terminal output and input manually\n    let cursor_pos = stdout.cursor_pos()?;\n    let mut index: usize = 0;\n\n    write!(stdout, \"{}\", cursor::Hide)?;\n    write!(stdout, \"{}\", cursor::Goto(0, cursor_pos.1))?;\n    stdout.flush()?;\n\n    for k in stdin.keys() {\n        match k? {\n            Key::Char('\\n') => break,\n            Key::Char(c) => {\n                //...Receives a normal character, so we apply it to the input string...\n            },\n            Key::Backspace => {\n                //...The user is trying to remove a character from the input, so we do it...\n            },\n            _ => () // Remains to add special characters: Control+C, Control+D, arrow keys, etc.\n        }\n        stdout.flush()?;\n    }\n\n    write!(stdout, \"{}{}\", cursor::Show, termion::clear::CurrentLine)?;\n    stdout.flush()?;\n\n    Ok(input)\n}\n```\n\n### Explanation\n\n-   **Entering Raw Mode:** `stdout().into_raw_mode().unwrap();` switches the terminal into raw mode, allowing us to handle input and output manually.\n-   **Hiding the Cursor:** `write!(stdout, \"{}\", cursor::Hide)?;` hides the real cursor and positions it at the beginning.\n-   **Reading Input:** The loop reads each key and handles characters and backspaces appropriately.\n\n### Why Termion?\n\nI chose **Termion** over **Crossterm** because Termion is more Unix-focused, which aligns with our shell's Unix base. Although Crossterm supports Windows, it is more complex to use. Since our shell won't work on Windows regardless, Termion is the better choice.\n\n### Future Improvements\n\nDue to some issues with Termion, the cursor has to be hidden and placed in the first column to ensure the input is written correctly. I added a \"fake\" cursor to mimic the real one while typing until I find a better solution. This workaround is temporary, but necessary for now.\n\n## What's Next?\n\nNext, we'll finish the basic input handling with Termion to accept more commands (e.g., Control+C) and use the up and down arrow keys to navigate through the command history. We'll also add a built-in command to manage the command history and write some tests to ensure everything works correctly, especially the command parser, which is crucial.\n\nStay tuned for the next post, where we'll continue improving our shell!";
						const data = {title:"Building a Unix-shell in Rust - Part 3",date:new Date(1722470400000),tags:["rust"],draft:false,summary:"In this post we will format the code and add some input functionality",author:{slug:"david",collection:"author"},customLayout:"PostLayout",customSlug:"building-a-unixshell-in-rust-part-3"};
						const _internal = {
							type: 'content',
							filePath: "C:/Users/david/Desktop/portfolio/src/content/blog/building-a-unixshell-in-rust-part-3.md",
							rawData: "\ntitle: Building a Unix-shell in Rust - Part 3\ndate: '2024-08-01'\ntags: ['rust']\ndraft: false\nsummary: In this post we will format the code and add some input functionality\nauthor: david\ncustomLayout: PostLayout\ncustomSlug: building-a-unixshell-in-rust-part-3",
						};

export { _internal, body, collection, data, id, slug };
